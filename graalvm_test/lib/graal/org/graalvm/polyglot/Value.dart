// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'Context.dart' as context$_;

/// from: `org.graalvm.polyglot.Value$StringEncoding`
class Value$StringEncoding extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Value$StringEncoding> $type;

  @jni$_.internal
  Value$StringEncoding.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/graalvm/polyglot/Value$StringEncoding',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Value$StringEncoding$NullableType();
  static const type = $Value$StringEncoding$Type();
  static final _id_UTF_8 = _class.staticFieldId(
    r'UTF_8',
    r'Lorg/graalvm/polyglot/Value$StringEncoding;',
  );

  /// from: `static public final org.graalvm.polyglot.Value$StringEncoding UTF_8`
  /// The returned object must be released after use, by calling the [release] method.
  static Value$StringEncoding? get UTF_8 =>
      _id_UTF_8.get(_class, const $Value$StringEncoding$NullableType());

  static final _id_UTF_16_LITTLE_ENDIAN = _class.staticFieldId(
    r'UTF_16_LITTLE_ENDIAN',
    r'Lorg/graalvm/polyglot/Value$StringEncoding;',
  );

  /// from: `static public final org.graalvm.polyglot.Value$StringEncoding UTF_16_LITTLE_ENDIAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Value$StringEncoding? get UTF_16_LITTLE_ENDIAN =>
      _id_UTF_16_LITTLE_ENDIAN.get(
        _class,
        const $Value$StringEncoding$NullableType(),
      );

  static final _id_UTF_16_BIG_ENDIAN = _class.staticFieldId(
    r'UTF_16_BIG_ENDIAN',
    r'Lorg/graalvm/polyglot/Value$StringEncoding;',
  );

  /// from: `static public final org.graalvm.polyglot.Value$StringEncoding UTF_16_BIG_ENDIAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Value$StringEncoding? get UTF_16_BIG_ENDIAN => _id_UTF_16_BIG_ENDIAN
      .get(_class, const $Value$StringEncoding$NullableType());

  static final _id_UTF_32_LITTLE_ENDIAN = _class.staticFieldId(
    r'UTF_32_LITTLE_ENDIAN',
    r'Lorg/graalvm/polyglot/Value$StringEncoding;',
  );

  /// from: `static public final org.graalvm.polyglot.Value$StringEncoding UTF_32_LITTLE_ENDIAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Value$StringEncoding? get UTF_32_LITTLE_ENDIAN =>
      _id_UTF_32_LITTLE_ENDIAN.get(
        _class,
        const $Value$StringEncoding$NullableType(),
      );

  static final _id_UTF_32_BIG_ENDIAN = _class.staticFieldId(
    r'UTF_32_BIG_ENDIAN',
    r'Lorg/graalvm/polyglot/Value$StringEncoding;',
  );

  /// from: `static public final org.graalvm.polyglot.Value$StringEncoding UTF_32_BIG_ENDIAN`
  /// The returned object must be released after use, by calling the [release] method.
  static Value$StringEncoding? get UTF_32_BIG_ENDIAN => _id_UTF_32_BIG_ENDIAN
      .get(_class, const $Value$StringEncoding$NullableType());

  static final _id_UTF_16 = _class.staticFieldId(
    r'UTF_16',
    r'Lorg/graalvm/polyglot/Value$StringEncoding;',
  );

  /// from: `static public final org.graalvm.polyglot.Value$StringEncoding UTF_16`
  /// The returned object must be released after use, by calling the [release] method.
  static Value$StringEncoding? get UTF_16 =>
      _id_UTF_16.get(_class, const $Value$StringEncoding$NullableType());

  static final _id_UTF_32 = _class.staticFieldId(
    r'UTF_32',
    r'Lorg/graalvm/polyglot/Value$StringEncoding;',
  );

  /// from: `static public final org.graalvm.polyglot.Value$StringEncoding UTF_32`
  /// The returned object must be released after use, by calling the [release] method.
  static Value$StringEncoding? get UTF_32 =>
      _id_UTF_32.get(_class, const $Value$StringEncoding$NullableType());
}

final class $Value$StringEncoding$NullableType
    extends jni$_.JObjType<Value$StringEncoding?> {
  @jni$_.internal
  const $Value$StringEncoding$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/graalvm/polyglot/Value$StringEncoding;';

  @jni$_.internal
  @core$_.override
  Value$StringEncoding? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Value$StringEncoding.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Value$StringEncoding?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Value$StringEncoding$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Value$StringEncoding$NullableType) &&
        other is $Value$StringEncoding$NullableType;
  }
}

final class $Value$StringEncoding$Type
    extends jni$_.JObjType<Value$StringEncoding> {
  @jni$_.internal
  const $Value$StringEncoding$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/graalvm/polyglot/Value$StringEncoding;';

  @jni$_.internal
  @core$_.override
  Value$StringEncoding fromReference(jni$_.JReference reference) =>
      Value$StringEncoding.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Value$StringEncoding?> get nullableType =>
      const $Value$StringEncoding$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Value$StringEncoding$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Value$StringEncoding$Type) &&
        other is $Value$StringEncoding$Type;
  }
}

/// from: `org.graalvm.polyglot.Value`
class Value extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Value> $type;

  @jni$_.internal
  Value.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/graalvm/polyglot/Value');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Value$NullableType();
  static const type = $Value$Type();
  static final _id_getMetaObject = _class.instanceMethodId(
    r'getMetaObject',
    r'()Lorg/graalvm/polyglot/Value;',
  );

  static final _getMetaObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getMetaObject()`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getMetaObject() {
    return _getMetaObject(
      reference.pointer,
      _id_getMetaObject as jni$_.JMethodIDPtr,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_isMetaObject = _class.instanceMethodId(
    r'isMetaObject',
    r'()Z',
  );

  static final _isMetaObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isMetaObject()`
  bool isMetaObject() {
    return _isMetaObject(
      reference.pointer,
      _id_isMetaObject as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getMetaQualifiedName = _class.instanceMethodId(
    r'getMetaQualifiedName',
    r'()Ljava/lang/String;',
  );

  static final _getMetaQualifiedName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getMetaQualifiedName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMetaQualifiedName() {
    return _getMetaQualifiedName(
      reference.pointer,
      _id_getMetaQualifiedName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getMetaSimpleName = _class.instanceMethodId(
    r'getMetaSimpleName',
    r'()Ljava/lang/String;',
  );

  static final _getMetaSimpleName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getMetaSimpleName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? getMetaSimpleName() {
    return _getMetaSimpleName(
      reference.pointer,
      _id_getMetaSimpleName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_isMetaInstance = _class.instanceMethodId(
    r'isMetaInstance',
    r'(Ljava/lang/Object;)Z',
  );

  static final _isMetaInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean isMetaInstance(java.lang.Object instance)`
  bool isMetaInstance(jni$_.JObject? instance) {
    final _$instance = instance?.reference ?? jni$_.jNullReference;
    return _isMetaInstance(
      reference.pointer,
      _id_isMetaInstance as jni$_.JMethodIDPtr,
      _$instance.pointer,
    ).boolean;
  }

  static final _id_hasMetaParents = _class.instanceMethodId(
    r'hasMetaParents',
    r'()Z',
  );

  static final _hasMetaParents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasMetaParents()`
  bool hasMetaParents() {
    return _hasMetaParents(
      reference.pointer,
      _id_hasMetaParents as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getMetaParents = _class.instanceMethodId(
    r'getMetaParents',
    r'()Lorg/graalvm/polyglot/Value;',
  );

  static final _getMetaParents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getMetaParents()`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getMetaParents() {
    return _getMetaParents(
      reference.pointer,
      _id_getMetaParents as jni$_.JMethodIDPtr,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_hasArrayElements = _class.instanceMethodId(
    r'hasArrayElements',
    r'()Z',
  );

  static final _hasArrayElements =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasArrayElements()`
  bool hasArrayElements() {
    return _hasArrayElements(
      reference.pointer,
      _id_hasArrayElements as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getArrayElement = _class.instanceMethodId(
    r'getArrayElement',
    r'(J)Lorg/graalvm/polyglot/Value;',
  );

  static final _getArrayElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getArrayElement(long index)`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getArrayElement(int index) {
    return _getArrayElement(
      reference.pointer,
      _id_getArrayElement as jni$_.JMethodIDPtr,
      index,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_setArrayElement = _class.instanceMethodId(
    r'setArrayElement',
    r'(JLjava/lang/Object;)V',
  );

  static final _setArrayElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setArrayElement(long index, java.lang.Object value)`
  void setArrayElement(int index, jni$_.JObject? value) {
    final _$value = value?.reference ?? jni$_.jNullReference;
    _setArrayElement(
      reference.pointer,
      _id_setArrayElement as jni$_.JMethodIDPtr,
      index,
      _$value.pointer,
    ).check();
  }

  static final _id_removeArrayElement = _class.instanceMethodId(
    r'removeArrayElement',
    r'(J)Z',
  );

  static final _removeArrayElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public boolean removeArrayElement(long index)`
  bool removeArrayElement(int index) {
    return _removeArrayElement(
      reference.pointer,
      _id_removeArrayElement as jni$_.JMethodIDPtr,
      index,
    ).boolean;
  }

  static final _id_getArraySize = _class.instanceMethodId(
    r'getArraySize',
    r'()J',
  );

  static final _getArraySize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getArraySize()`
  int getArraySize() {
    return _getArraySize(
      reference.pointer,
      _id_getArraySize as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_hasBufferElements = _class.instanceMethodId(
    r'hasBufferElements',
    r'()Z',
  );

  static final _hasBufferElements =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasBufferElements()`
  bool hasBufferElements() {
    return _hasBufferElements(
      reference.pointer,
      _id_hasBufferElements as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isBufferWritable = _class.instanceMethodId(
    r'isBufferWritable',
    r'()Z',
  );

  static final _isBufferWritable =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBufferWritable()`
  bool isBufferWritable() {
    return _isBufferWritable(
      reference.pointer,
      _id_isBufferWritable as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getBufferSize = _class.instanceMethodId(
    r'getBufferSize',
    r'()J',
  );

  static final _getBufferSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getBufferSize()`
  int getBufferSize() {
    return _getBufferSize(
      reference.pointer,
      _id_getBufferSize as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_readBufferByte = _class.instanceMethodId(
    r'readBufferByte',
    r'(J)B',
  );

  static final _readBufferByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64,)>,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public byte readBufferByte(long byteOffset)`
  int readBufferByte(int byteOffset) {
    return _readBufferByte(
      reference.pointer,
      _id_readBufferByte as jni$_.JMethodIDPtr,
      byteOffset,
    ).byte;
  }

  static final _id_readBuffer = _class.instanceMethodId(
    r'readBuffer',
    r'(J[BII)V',
  );

  static final _readBuffer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int64,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void readBuffer(long byteOffset, byte[] destination, int destinationOffset, int length)`
  void readBuffer(
    int byteOffset,
    jni$_.JByteArray? destination,
    int destinationOffset,
    int length,
  ) {
    final _$destination = destination?.reference ?? jni$_.jNullReference;
    _readBuffer(
      reference.pointer,
      _id_readBuffer as jni$_.JMethodIDPtr,
      byteOffset,
      _$destination.pointer,
      destinationOffset,
      length,
    ).check();
  }

  static final _id_writeBufferByte = _class.instanceMethodId(
    r'writeBufferByte',
    r'(JB)V',
  );

  static final _writeBufferByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int64, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
            )
          >();

  /// from: `public void writeBufferByte(long byteOffset, byte value)`
  void writeBufferByte(int byteOffset, int value) {
    _writeBufferByte(
      reference.pointer,
      _id_writeBufferByte as jni$_.JMethodIDPtr,
      byteOffset,
      value,
    ).check();
  }

  static final _id_readBufferShort = _class.instanceMethodId(
    r'readBufferShort',
    r'(Ljava/nio/ByteOrder;J)S',
  );

  static final _readBufferShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public short readBufferShort(java.nio.ByteOrder order, long byteOffset)`
  int readBufferShort(jni$_.JObject? order, int byteOffset) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    return _readBufferShort(
      reference.pointer,
      _id_readBufferShort as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
    ).short;
  }

  static final _id_writeBufferShort = _class.instanceMethodId(
    r'writeBufferShort',
    r'(Ljava/nio/ByteOrder;JS)V',
  );

  static final _writeBufferShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int64, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void writeBufferShort(java.nio.ByteOrder order, long byteOffset, short value)`
  void writeBufferShort(jni$_.JObject? order, int byteOffset, int value) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    _writeBufferShort(
      reference.pointer,
      _id_writeBufferShort as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
      value,
    ).check();
  }

  static final _id_readBufferInt = _class.instanceMethodId(
    r'readBufferInt',
    r'(Ljava/nio/ByteOrder;J)I',
  );

  static final _readBufferInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public int readBufferInt(java.nio.ByteOrder order, long byteOffset)`
  int readBufferInt(jni$_.JObject? order, int byteOffset) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    return _readBufferInt(
      reference.pointer,
      _id_readBufferInt as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
    ).integer;
  }

  static final _id_writeBufferInt = _class.instanceMethodId(
    r'writeBufferInt',
    r'(Ljava/nio/ByteOrder;JI)V',
  );

  static final _writeBufferInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int64, jni$_.Int32)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void writeBufferInt(java.nio.ByteOrder order, long byteOffset, int value)`
  void writeBufferInt(jni$_.JObject? order, int byteOffset, int value) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    _writeBufferInt(
      reference.pointer,
      _id_writeBufferInt as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
      value,
    ).check();
  }

  static final _id_readBufferLong = _class.instanceMethodId(
    r'readBufferLong',
    r'(Ljava/nio/ByteOrder;J)J',
  );

  static final _readBufferLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public long readBufferLong(java.nio.ByteOrder order, long byteOffset)`
  int readBufferLong(jni$_.JObject? order, int byteOffset) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    return _readBufferLong(
      reference.pointer,
      _id_readBufferLong as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
    ).long;
  }

  static final _id_writeBufferLong = _class.instanceMethodId(
    r'writeBufferLong',
    r'(Ljava/nio/ByteOrder;JJ)V',
  );

  static final _writeBufferLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int64, jni$_.Int64)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
            )
          >();

  /// from: `public void writeBufferLong(java.nio.ByteOrder order, long byteOffset, long value)`
  void writeBufferLong(jni$_.JObject? order, int byteOffset, int value) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    _writeBufferLong(
      reference.pointer,
      _id_writeBufferLong as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
      value,
    ).check();
  }

  static final _id_readBufferFloat = _class.instanceMethodId(
    r'readBufferFloat',
    r'(Ljava/nio/ByteOrder;J)F',
  );

  static final _readBufferFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public float readBufferFloat(java.nio.ByteOrder order, long byteOffset)`
  double readBufferFloat(jni$_.JObject? order, int byteOffset) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    return _readBufferFloat(
      reference.pointer,
      _id_readBufferFloat as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
    ).float;
  }

  static final _id_writeBufferFloat = _class.instanceMethodId(
    r'writeBufferFloat',
    r'(Ljava/nio/ByteOrder;JF)V',
  );

  static final _writeBufferFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int64, jni$_.Double)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              double,
            )
          >();

  /// from: `public void writeBufferFloat(java.nio.ByteOrder order, long byteOffset, float value)`
  void writeBufferFloat(jni$_.JObject? order, int byteOffset, double value) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    _writeBufferFloat(
      reference.pointer,
      _id_writeBufferFloat as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
      value,
    ).check();
  }

  static final _id_readBufferDouble = _class.instanceMethodId(
    r'readBufferDouble',
    r'(Ljava/nio/ByteOrder;J)D',
  );

  static final _readBufferDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public double readBufferDouble(java.nio.ByteOrder order, long byteOffset)`
  double readBufferDouble(jni$_.JObject? order, int byteOffset) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    return _readBufferDouble(
      reference.pointer,
      _id_readBufferDouble as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
    ).doubleFloat;
  }

  static final _id_writeBufferDouble = _class.instanceMethodId(
    r'writeBufferDouble',
    r'(Ljava/nio/ByteOrder;JD)V',
  );

  static final _writeBufferDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Int64, jni$_.Double)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              double,
            )
          >();

  /// from: `public void writeBufferDouble(java.nio.ByteOrder order, long byteOffset, double value)`
  void writeBufferDouble(jni$_.JObject? order, int byteOffset, double value) {
    final _$order = order?.reference ?? jni$_.jNullReference;
    _writeBufferDouble(
      reference.pointer,
      _id_writeBufferDouble as jni$_.JMethodIDPtr,
      _$order.pointer,
      byteOffset,
      value,
    ).check();
  }

  static final _id_hasMembers = _class.instanceMethodId(r'hasMembers', r'()Z');

  static final _hasMembers =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasMembers()`
  bool hasMembers() {
    return _hasMembers(
      reference.pointer,
      _id_hasMembers as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_hasMember = _class.instanceMethodId(
    r'hasMember',
    r'(Ljava/lang/String;)Z',
  );

  static final _hasMember =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasMember(java.lang.String identifier)`
  bool hasMember(jni$_.JString? identifier) {
    final _$identifier = identifier?.reference ?? jni$_.jNullReference;
    return _hasMember(
      reference.pointer,
      _id_hasMember as jni$_.JMethodIDPtr,
      _$identifier.pointer,
    ).boolean;
  }

  static final _id_getMember = _class.instanceMethodId(
    r'getMember',
    r'(Ljava/lang/String;)Lorg/graalvm/polyglot/Value;',
  );

  static final _getMember =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getMember(java.lang.String identifier)`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getMember(jni$_.JString? identifier) {
    final _$identifier = identifier?.reference ?? jni$_.jNullReference;
    return _getMember(
      reference.pointer,
      _id_getMember as jni$_.JMethodIDPtr,
      _$identifier.pointer,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_getMemberKeys = _class.instanceMethodId(
    r'getMemberKeys',
    r'()Ljava/util/Set;',
  );

  static final _getMemberKeys =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.lang.String> getMemberKeys()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JSet<jni$_.JString?>? getMemberKeys() {
    return _getMemberKeys(
      reference.pointer,
      _id_getMemberKeys as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JString?>?>(
      const jni$_.JSetNullableType<jni$_.JString?>(jni$_.JStringNullableType()),
    );
  }

  static final _id_putMember = _class.instanceMethodId(
    r'putMember',
    r'(Ljava/lang/String;Ljava/lang/Object;)V',
  );

  static final _putMember =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void putMember(java.lang.String identifier, java.lang.Object value)`
  void putMember(jni$_.JString? identifier, jni$_.JObject? value) {
    final _$identifier = identifier?.reference ?? jni$_.jNullReference;
    final _$value = value?.reference ?? jni$_.jNullReference;
    _putMember(
      reference.pointer,
      _id_putMember as jni$_.JMethodIDPtr,
      _$identifier.pointer,
      _$value.pointer,
    ).check();
  }

  static final _id_removeMember = _class.instanceMethodId(
    r'removeMember',
    r'(Ljava/lang/String;)Z',
  );

  static final _removeMember =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean removeMember(java.lang.String identifier)`
  bool removeMember(jni$_.JString? identifier) {
    final _$identifier = identifier?.reference ?? jni$_.jNullReference;
    return _removeMember(
      reference.pointer,
      _id_removeMember as jni$_.JMethodIDPtr,
      _$identifier.pointer,
    ).boolean;
  }

  static final _id_canExecute = _class.instanceMethodId(r'canExecute', r'()Z');

  static final _canExecute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canExecute()`
  bool canExecute() {
    return _canExecute(
      reference.pointer,
      _id_canExecute as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_execute = _class.instanceMethodId(
    r'execute',
    r'([Ljava/lang/Object;)Lorg/graalvm/polyglot/Value;',
  );

  static final _execute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value execute(java.lang.Object[] arguments)`
  /// The returned object must be released after use, by calling the [release] method.
  Value? execute(jni$_.JArray<jni$_.JObject?>? arguments) {
    final _$arguments = arguments?.reference ?? jni$_.jNullReference;
    return _execute(
      reference.pointer,
      _id_execute as jni$_.JMethodIDPtr,
      _$arguments.pointer,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_executeVoid = _class.instanceMethodId(
    r'executeVoid',
    r'([Ljava/lang/Object;)V',
  );

  static final _executeVoid =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void executeVoid(java.lang.Object[] arguments)`
  void executeVoid(jni$_.JArray<jni$_.JObject?>? arguments) {
    final _$arguments = arguments?.reference ?? jni$_.jNullReference;
    _executeVoid(
      reference.pointer,
      _id_executeVoid as jni$_.JMethodIDPtr,
      _$arguments.pointer,
    ).check();
  }

  static final _id_canInstantiate = _class.instanceMethodId(
    r'canInstantiate',
    r'()Z',
  );

  static final _canInstantiate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean canInstantiate()`
  bool canInstantiate() {
    return _canInstantiate(
      reference.pointer,
      _id_canInstantiate as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_newInstance = _class.instanceMethodId(
    r'newInstance',
    r'([Ljava/lang/Object;)Lorg/graalvm/polyglot/Value;',
  );

  static final _newInstance =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value newInstance(java.lang.Object[] arguments)`
  /// The returned object must be released after use, by calling the [release] method.
  Value? newInstance(jni$_.JArray<jni$_.JObject?>? arguments) {
    final _$arguments = arguments?.reference ?? jni$_.jNullReference;
    return _newInstance(
      reference.pointer,
      _id_newInstance as jni$_.JMethodIDPtr,
      _$arguments.pointer,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_canInvokeMember = _class.instanceMethodId(
    r'canInvokeMember',
    r'(Ljava/lang/String;)Z',
  );

  static final _canInvokeMember =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean canInvokeMember(java.lang.String identifier)`
  bool canInvokeMember(jni$_.JString? identifier) {
    final _$identifier = identifier?.reference ?? jni$_.jNullReference;
    return _canInvokeMember(
      reference.pointer,
      _id_canInvokeMember as jni$_.JMethodIDPtr,
      _$identifier.pointer,
    ).boolean;
  }

  static final _id_invokeMember = _class.instanceMethodId(
    r'invokeMember',
    r'(Ljava/lang/String;[Ljava/lang/Object;)Lorg/graalvm/polyglot/Value;',
  );

  static final _invokeMember =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value invokeMember(java.lang.String identifier, java.lang.Object[] arguments)`
  /// The returned object must be released after use, by calling the [release] method.
  Value? invokeMember(
    jni$_.JString? identifier,
    jni$_.JArray<jni$_.JObject?>? arguments,
  ) {
    final _$identifier = identifier?.reference ?? jni$_.jNullReference;
    final _$arguments = arguments?.reference ?? jni$_.jNullReference;
    return _invokeMember(
      reference.pointer,
      _id_invokeMember as jni$_.JMethodIDPtr,
      _$identifier.pointer,
      _$arguments.pointer,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_isString = _class.instanceMethodId(r'isString', r'()Z');

  static final _isString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isString()`
  bool isString() {
    return _isString(
      reference.pointer,
      _id_isString as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asString = _class.instanceMethodId(
    r'asString',
    r'()Ljava/lang/String;',
  );

  static final _asString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String asString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? asString() {
    return _asString(
      reference.pointer,
      _id_asString as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_asStringBytes = _class.instanceMethodId(
    r'asStringBytes',
    r'(Lorg/graalvm/polyglot/Value$StringEncoding;)[B',
  );

  static final _asStringBytes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public byte[] asStringBytes(org.graalvm.polyglot.Value$StringEncoding encoding)`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JByteArray? asStringBytes(Value$StringEncoding? encoding) {
    final _$encoding = encoding?.reference ?? jni$_.jNullReference;
    return _asStringBytes(
      reference.pointer,
      _id_asStringBytes as jni$_.JMethodIDPtr,
      _$encoding.pointer,
    ).object<jni$_.JByteArray?>(const jni$_.JByteArrayNullableType());
  }

  static final _id_fitsInInt = _class.instanceMethodId(r'fitsInInt', r'()Z');

  static final _fitsInInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean fitsInInt()`
  bool fitsInInt() {
    return _fitsInInt(
      reference.pointer,
      _id_fitsInInt as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asInt = _class.instanceMethodId(r'asInt', r'()I');

  static final _asInt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int asInt()`
  int asInt() {
    return _asInt(reference.pointer, _id_asInt as jni$_.JMethodIDPtr).integer;
  }

  static final _id_isBoolean = _class.instanceMethodId(r'isBoolean', r'()Z');

  static final _isBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBoolean()`
  bool isBoolean() {
    return _isBoolean(
      reference.pointer,
      _id_isBoolean as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asBoolean = _class.instanceMethodId(r'asBoolean', r'()Z');

  static final _asBoolean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean asBoolean()`
  bool asBoolean() {
    return _asBoolean(
      reference.pointer,
      _id_asBoolean as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isNumber = _class.instanceMethodId(r'isNumber', r'()Z');

  static final _isNumber =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isNumber()`
  bool isNumber() {
    return _isNumber(
      reference.pointer,
      _id_isNumber as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_fitsInLong = _class.instanceMethodId(r'fitsInLong', r'()Z');

  static final _fitsInLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean fitsInLong()`
  bool fitsInLong() {
    return _fitsInLong(
      reference.pointer,
      _id_fitsInLong as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asLong = _class.instanceMethodId(r'asLong', r'()J');

  static final _asLong =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long asLong()`
  int asLong() {
    return _asLong(reference.pointer, _id_asLong as jni$_.JMethodIDPtr).long;
  }

  static final _id_fitsInBigInteger = _class.instanceMethodId(
    r'fitsInBigInteger',
    r'()Z',
  );

  static final _fitsInBigInteger =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean fitsInBigInteger()`
  bool fitsInBigInteger() {
    return _fitsInBigInteger(
      reference.pointer,
      _id_fitsInBigInteger as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asBigInteger = _class.instanceMethodId(
    r'asBigInteger',
    r'()Ljava/math/BigInteger;',
  );

  static final _asBigInteger =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.math.BigInteger asBigInteger()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? asBigInteger() {
    return _asBigInteger(
      reference.pointer,
      _id_asBigInteger as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_fitsInDouble = _class.instanceMethodId(
    r'fitsInDouble',
    r'()Z',
  );

  static final _fitsInDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean fitsInDouble()`
  bool fitsInDouble() {
    return _fitsInDouble(
      reference.pointer,
      _id_fitsInDouble as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asDouble = _class.instanceMethodId(r'asDouble', r'()D');

  static final _asDouble =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallDoubleMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public double asDouble()`
  double asDouble() {
    return _asDouble(
      reference.pointer,
      _id_asDouble as jni$_.JMethodIDPtr,
    ).doubleFloat;
  }

  static final _id_fitsInFloat = _class.instanceMethodId(
    r'fitsInFloat',
    r'()Z',
  );

  static final _fitsInFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean fitsInFloat()`
  bool fitsInFloat() {
    return _fitsInFloat(
      reference.pointer,
      _id_fitsInFloat as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asFloat = _class.instanceMethodId(r'asFloat', r'()F');

  static final _asFloat =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallFloatMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public float asFloat()`
  double asFloat() {
    return _asFloat(reference.pointer, _id_asFloat as jni$_.JMethodIDPtr).float;
  }

  static final _id_fitsInByte = _class.instanceMethodId(r'fitsInByte', r'()Z');

  static final _fitsInByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean fitsInByte()`
  bool fitsInByte() {
    return _fitsInByte(
      reference.pointer,
      _id_fitsInByte as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asByte = _class.instanceMethodId(r'asByte', r'()B');

  static final _asByte =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallByteMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public byte asByte()`
  int asByte() {
    return _asByte(reference.pointer, _id_asByte as jni$_.JMethodIDPtr).byte;
  }

  static final _id_fitsInShort = _class.instanceMethodId(
    r'fitsInShort',
    r'()Z',
  );

  static final _fitsInShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean fitsInShort()`
  bool fitsInShort() {
    return _fitsInShort(
      reference.pointer,
      _id_fitsInShort as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asShort = _class.instanceMethodId(r'asShort', r'()S');

  static final _asShort =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallShortMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public short asShort()`
  int asShort() {
    return _asShort(reference.pointer, _id_asShort as jni$_.JMethodIDPtr).short;
  }

  static final _id_isNull$1 = _class.instanceMethodId(r'isNull', r'()Z');

  static final _isNull$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isNull()`
  bool isNull$1() {
    return _isNull$1(
      reference.pointer,
      _id_isNull$1 as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_isNativePointer = _class.instanceMethodId(
    r'isNativePointer',
    r'()Z',
  );

  static final _isNativePointer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isNativePointer()`
  bool isNativePointer() {
    return _isNativePointer(
      reference.pointer,
      _id_isNativePointer as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asNativePointer = _class.instanceMethodId(
    r'asNativePointer',
    r'()J',
  );

  static final _asNativePointer =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long asNativePointer()`
  int asNativePointer() {
    return _asNativePointer(
      reference.pointer,
      _id_asNativePointer as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_isHostObject = _class.instanceMethodId(
    r'isHostObject',
    r'()Z',
  );

  static final _isHostObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isHostObject()`
  bool isHostObject() {
    return _isHostObject(
      reference.pointer,
      _id_isHostObject as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asHostObject = _class.instanceMethodId(
    r'asHostObject',
    r'()Ljava/lang/Object;',
  );

  static final _asHostObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T asHostObject()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? asHostObject<$T extends jni$_.JObject?>({required jni$_.JObjType<$T> T}) {
    return _asHostObject(
      reference.pointer,
      _id_asHostObject as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_isProxyObject = _class.instanceMethodId(
    r'isProxyObject',
    r'()Z',
  );

  static final _isProxyObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isProxyObject()`
  bool isProxyObject() {
    return _isProxyObject(
      reference.pointer,
      _id_isProxyObject as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asProxyObject = _class.instanceMethodId(
    r'asProxyObject',
    r'()Lorg/graalvm/polyglot/proxy/Proxy;',
  );

  static final _asProxyObject =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public T asProxyObject()`
  /// The returned object must be released after use, by calling the [release] method.
  $T? asProxyObject<$T extends jni$_.JObject?>({
    required jni$_.JObjType<$T> T,
  }) {
    return _asProxyObject(
      reference.pointer,
      _id_asProxyObject as jni$_.JMethodIDPtr,
    ).object<$T?>(T.nullableType);
  }

  static final _id_as$1 = _class.instanceMethodId(
    r'as',
    r'(Ljava/lang/Class;)Ljava/lang/Object;',
  );

  static final _as$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T as(java.lang.Class<T> targetType)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? as$1<$T extends jni$_.JObject?>(
    jni$_.JObject? targetType, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$targetType = targetType?.reference ?? jni$_.jNullReference;
    return _as$1(
      reference.pointer,
      _id_as$1 as jni$_.JMethodIDPtr,
      _$targetType.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_as$2 = _class.instanceMethodId(
    r'as',
    r'(Lorg/graalvm/polyglot/TypeLiteral;)Ljava/lang/Object;',
  );

  static final _as$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T as(org.graalvm.polyglot.TypeLiteral<T> targetType)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? as$2<$T extends jni$_.JObject?>(
    jni$_.JObject? targetType, {
    required jni$_.JObjType<$T> T,
  }) {
    final _$targetType = targetType?.reference ?? jni$_.jNullReference;
    return _as$2(
      reference.pointer,
      _id_as$2 as jni$_.JMethodIDPtr,
      _$targetType.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getSourceLocation = _class.instanceMethodId(
    r'getSourceLocation',
    r'()Lorg/graalvm/polyglot/SourceSection;',
  );

  static final _getSourceLocation =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.SourceSection getSourceLocation()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getSourceLocation() {
    return _getSourceLocation(
      reference.pointer,
      _id_getSourceLocation as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isDate = _class.instanceMethodId(r'isDate', r'()Z');

  static final _isDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDate()`
  bool isDate() {
    return _isDate(reference.pointer, _id_isDate as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_asDate = _class.instanceMethodId(
    r'asDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _asDate =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalDate asDate()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? asDate() {
    return _asDate(
      reference.pointer,
      _id_asDate as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isTime = _class.instanceMethodId(r'isTime', r'()Z');

  static final _isTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isTime()`
  bool isTime() {
    return _isTime(reference.pointer, _id_isTime as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_asTime = _class.instanceMethodId(
    r'asTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _asTime =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.LocalTime asTime()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? asTime() {
    return _asTime(
      reference.pointer,
      _id_asTime as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isInstant = _class.instanceMethodId(r'isInstant', r'()Z');

  static final _isInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isInstant()`
  bool isInstant() {
    return _isInstant(
      reference.pointer,
      _id_isInstant as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asInstant = _class.instanceMethodId(
    r'asInstant',
    r'()Ljava/time/Instant;',
  );

  static final _asInstant =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Instant asInstant()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? asInstant() {
    return _asInstant(
      reference.pointer,
      _id_asInstant as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isTimeZone = _class.instanceMethodId(r'isTimeZone', r'()Z');

  static final _isTimeZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isTimeZone()`
  bool isTimeZone() {
    return _isTimeZone(
      reference.pointer,
      _id_isTimeZone as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asTimeZone = _class.instanceMethodId(
    r'asTimeZone',
    r'()Ljava/time/ZoneId;',
  );

  static final _asTimeZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.ZoneId asTimeZone()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? asTimeZone() {
    return _asTimeZone(
      reference.pointer,
      _id_asTimeZone as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isDuration = _class.instanceMethodId(r'isDuration', r'()Z');

  static final _isDuration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isDuration()`
  bool isDuration() {
    return _isDuration(
      reference.pointer,
      _id_isDuration as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_asDuration = _class.instanceMethodId(
    r'asDuration',
    r'()Ljava/time/Duration;',
  );

  static final _asDuration =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.time.Duration asDuration()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? asDuration() {
    return _asDuration(
      reference.pointer,
      _id_asDuration as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isException = _class.instanceMethodId(
    r'isException',
    r'()Z',
  );

  static final _isException =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isException()`
  bool isException() {
    return _isException(
      reference.pointer,
      _id_isException as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_throwException = _class.instanceMethodId(
    r'throwException',
    r'()Ljava/lang/RuntimeException;',
  );

  static final _throwException =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.RuntimeException throwException()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? throwException() {
    return _throwException(
      reference.pointer,
      _id_throwException as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getContext = _class.instanceMethodId(
    r'getContext',
    r'()Lorg/graalvm/polyglot/Context;',
  );

  static final _getContext =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context getContext()`
  /// The returned object must be released after use, by calling the [release] method.
  context$_.Context? getContext() {
    return _getContext(
      reference.pointer,
      _id_getContext as jni$_.JMethodIDPtr,
    ).object<context$_.Context?>(const context$_.$Context$NullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object obj)`
  bool equals(jni$_.JObject? obj) {
    final _$obj = obj?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$obj.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_hasIterator = _class.instanceMethodId(
    r'hasIterator',
    r'()Z',
  );

  static final _hasIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasIterator()`
  bool hasIterator() {
    return _hasIterator(
      reference.pointer,
      _id_hasIterator as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getIterator = _class.instanceMethodId(
    r'getIterator',
    r'()Lorg/graalvm/polyglot/Value;',
  );

  static final _getIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getIterator()`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getIterator() {
    return _getIterator(
      reference.pointer,
      _id_getIterator as jni$_.JMethodIDPtr,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_isIterator = _class.instanceMethodId(r'isIterator', r'()Z');

  static final _isIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isIterator()`
  bool isIterator() {
    return _isIterator(
      reference.pointer,
      _id_isIterator as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_hasIteratorNextElement = _class.instanceMethodId(
    r'hasIteratorNextElement',
    r'()Z',
  );

  static final _hasIteratorNextElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasIteratorNextElement()`
  bool hasIteratorNextElement() {
    return _hasIteratorNextElement(
      reference.pointer,
      _id_hasIteratorNextElement as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getIteratorNextElement = _class.instanceMethodId(
    r'getIteratorNextElement',
    r'()Lorg/graalvm/polyglot/Value;',
  );

  static final _getIteratorNextElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getIteratorNextElement()`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getIteratorNextElement() {
    return _getIteratorNextElement(
      reference.pointer,
      _id_getIteratorNextElement as jni$_.JMethodIDPtr,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_hasHashEntries = _class.instanceMethodId(
    r'hasHashEntries',
    r'()Z',
  );

  static final _hasHashEntries =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasHashEntries()`
  bool hasHashEntries() {
    return _hasHashEntries(
      reference.pointer,
      _id_hasHashEntries as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_getHashSize = _class.instanceMethodId(
    r'getHashSize',
    r'()J',
  );

  static final _getHashSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallLongMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public long getHashSize()`
  int getHashSize() {
    return _getHashSize(
      reference.pointer,
      _id_getHashSize as jni$_.JMethodIDPtr,
    ).long;
  }

  static final _id_hasHashEntry = _class.instanceMethodId(
    r'hasHashEntry',
    r'(Ljava/lang/Object;)Z',
  );

  static final _hasHashEntry =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasHashEntry(java.lang.Object key)`
  bool hasHashEntry(jni$_.JObject? key) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    return _hasHashEntry(
      reference.pointer,
      _id_hasHashEntry as jni$_.JMethodIDPtr,
      _$key.pointer,
    ).boolean;
  }

  static final _id_getHashValue = _class.instanceMethodId(
    r'getHashValue',
    r'(Ljava/lang/Object;)Lorg/graalvm/polyglot/Value;',
  );

  static final _getHashValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getHashValue(java.lang.Object key)`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getHashValue(jni$_.JObject? key) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    return _getHashValue(
      reference.pointer,
      _id_getHashValue as jni$_.JMethodIDPtr,
      _$key.pointer,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_getHashValueOrDefault = _class.instanceMethodId(
    r'getHashValueOrDefault',
    r'(Ljava/lang/Object;Ljava/lang/Object;)Lorg/graalvm/polyglot/Value;',
  );

  static final _getHashValueOrDefault =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getHashValueOrDefault(java.lang.Object key, java.lang.Object defaultValue)`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getHashValueOrDefault(
    jni$_.JObject? key,
    jni$_.JObject? defaultValue,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$defaultValue = defaultValue?.reference ?? jni$_.jNullReference;
    return _getHashValueOrDefault(
      reference.pointer,
      _id_getHashValueOrDefault as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$defaultValue.pointer,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_putHashEntry = _class.instanceMethodId(
    r'putHashEntry',
    r'(Ljava/lang/Object;Ljava/lang/Object;)V',
  );

  static final _putHashEntry =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void putHashEntry(java.lang.Object key, java.lang.Object value)`
  void putHashEntry(jni$_.JObject? key, jni$_.JObject? value) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$value = value?.reference ?? jni$_.jNullReference;
    _putHashEntry(
      reference.pointer,
      _id_putHashEntry as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$value.pointer,
    ).check();
  }

  static final _id_removeHashEntry = _class.instanceMethodId(
    r'removeHashEntry',
    r'(Ljava/lang/Object;)Z',
  );

  static final _removeHashEntry =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean removeHashEntry(java.lang.Object key)`
  bool removeHashEntry(jni$_.JObject? key) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    return _removeHashEntry(
      reference.pointer,
      _id_removeHashEntry as jni$_.JMethodIDPtr,
      _$key.pointer,
    ).boolean;
  }

  static final _id_getHashEntriesIterator = _class.instanceMethodId(
    r'getHashEntriesIterator',
    r'()Lorg/graalvm/polyglot/Value;',
  );

  static final _getHashEntriesIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getHashEntriesIterator()`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getHashEntriesIterator() {
    return _getHashEntriesIterator(
      reference.pointer,
      _id_getHashEntriesIterator as jni$_.JMethodIDPtr,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_getHashKeysIterator = _class.instanceMethodId(
    r'getHashKeysIterator',
    r'()Lorg/graalvm/polyglot/Value;',
  );

  static final _getHashKeysIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getHashKeysIterator()`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getHashKeysIterator() {
    return _getHashKeysIterator(
      reference.pointer,
      _id_getHashKeysIterator as jni$_.JMethodIDPtr,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_getHashValuesIterator = _class.instanceMethodId(
    r'getHashValuesIterator',
    r'()Lorg/graalvm/polyglot/Value;',
  );

  static final _getHashValuesIterator =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getHashValuesIterator()`
  /// The returned object must be released after use, by calling the [release] method.
  Value? getHashValuesIterator() {
    return _getHashValuesIterator(
      reference.pointer,
      _id_getHashValuesIterator as jni$_.JMethodIDPtr,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_asValue = _class.staticMethodId(
    r'asValue',
    r'(Ljava/lang/Object;)Lorg/graalvm/polyglot/Value;',
  );

  static final _asValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.graalvm.polyglot.Value asValue(java.lang.Object o)`
  /// The returned object must be released after use, by calling the [release] method.
  static Value? asValue(jni$_.JObject? o) {
    final _$o = o?.reference ?? jni$_.jNullReference;
    return _asValue(
      _class.reference.pointer,
      _id_asValue as jni$_.JMethodIDPtr,
      _$o.pointer,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_pin = _class.instanceMethodId(r'pin', r'()V');

  static final _pin =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void pin()`
  void pin() {
    _pin(reference.pointer, _id_pin as jni$_.JMethodIDPtr).check();
  }

  static final _id_fromByteBasedString = _class.staticMethodId(
    r'fromByteBasedString',
    r'([BLorg/graalvm/polyglot/Value$StringEncoding;)Lorg/graalvm/polyglot/Value;',
  );

  static final _fromByteBasedString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.graalvm.polyglot.Value fromByteBasedString(byte[] bytes, org.graalvm.polyglot.Value$StringEncoding encoding)`
  /// The returned object must be released after use, by calling the [release] method.
  static Value? fromByteBasedString(
    jni$_.JByteArray? bytes,
    Value$StringEncoding? encoding,
  ) {
    final _$bytes = bytes?.reference ?? jni$_.jNullReference;
    final _$encoding = encoding?.reference ?? jni$_.jNullReference;
    return _fromByteBasedString(
      _class.reference.pointer,
      _id_fromByteBasedString as jni$_.JMethodIDPtr,
      _$bytes.pointer,
      _$encoding.pointer,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_fromByteBasedString$1 = _class.staticMethodId(
    r'fromByteBasedString',
    r'([BIILorg/graalvm/polyglot/Value$StringEncoding;Z)Lorg/graalvm/polyglot/Value;',
  );

  static final _fromByteBasedString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.graalvm.polyglot.Value fromByteBasedString(byte[] bytes, int offset, int length, org.graalvm.polyglot.Value$StringEncoding encoding, boolean copy)`
  /// The returned object must be released after use, by calling the [release] method.
  static Value? fromByteBasedString$1(
    jni$_.JByteArray? bytes,
    int offset,
    int length,
    Value$StringEncoding? encoding,
    bool copy,
  ) {
    final _$bytes = bytes?.reference ?? jni$_.jNullReference;
    final _$encoding = encoding?.reference ?? jni$_.jNullReference;
    return _fromByteBasedString$1(
      _class.reference.pointer,
      _id_fromByteBasedString$1 as jni$_.JMethodIDPtr,
      _$bytes.pointer,
      offset,
      length,
      _$encoding.pointer,
      copy ? 1 : 0,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_fromNativeString = _class.staticMethodId(
    r'fromNativeString',
    r'(JIILorg/graalvm/polyglot/Value$StringEncoding;Z)Lorg/graalvm/polyglot/Value;',
  );

  static final _fromNativeString =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Int64,
                    jni$_.Int32,
                    jni$_.Int32,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Int32,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.graalvm.polyglot.Value fromNativeString(long basePointer, int byteOffset, int byteLength, org.graalvm.polyglot.Value$StringEncoding encoding, boolean copy)`
  /// The returned object must be released after use, by calling the [release] method.
  static Value? fromNativeString(
    int basePointer,
    int byteOffset,
    int byteLength,
    Value$StringEncoding? encoding,
    bool copy,
  ) {
    final _$encoding = encoding?.reference ?? jni$_.jNullReference;
    return _fromNativeString(
      _class.reference.pointer,
      _id_fromNativeString as jni$_.JMethodIDPtr,
      basePointer,
      byteOffset,
      byteLength,
      _$encoding.pointer,
      copy ? 1 : 0,
    ).object<Value?>(const $Value$NullableType());
  }

  static final _id_fromNativeString$1 = _class.staticMethodId(
    r'fromNativeString',
    r'(JILorg/graalvm/polyglot/Value$StringEncoding;)Lorg/graalvm/polyglot/Value;',
  );

  static final _fromNativeString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Int64, jni$_.Int32, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.graalvm.polyglot.Value fromNativeString(long basePointer, int byteLength, org.graalvm.polyglot.Value$StringEncoding encoding)`
  /// The returned object must be released after use, by calling the [release] method.
  static Value? fromNativeString$1(
    int basePointer,
    int byteLength,
    Value$StringEncoding? encoding,
  ) {
    final _$encoding = encoding?.reference ?? jni$_.jNullReference;
    return _fromNativeString$1(
      _class.reference.pointer,
      _id_fromNativeString$1 as jni$_.JMethodIDPtr,
      basePointer,
      byteLength,
      _$encoding.pointer,
    ).object<Value?>(const $Value$NullableType());
  }
}

final class $Value$NullableType extends jni$_.JObjType<Value?> {
  @jni$_.internal
  const $Value$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/graalvm/polyglot/Value;';

  @jni$_.internal
  @core$_.override
  Value? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Value.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Value?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Value$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Value$NullableType) &&
        other is $Value$NullableType;
  }
}

final class $Value$Type extends jni$_.JObjType<Value> {
  @jni$_.internal
  const $Value$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/graalvm/polyglot/Value;';

  @jni$_.internal
  @core$_.override
  Value fromReference(jni$_.JReference reference) =>
      Value.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Value?> get nullableType => const $Value$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Value$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Value$Type) && other is $Value$Type;
  }
}
