// AUTO GENERATED BY JNIGEN 0.14.2. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'Value.dart' as value$_;

/// from: `org.graalvm.polyglot.Context$Builder`
class Context$Builder extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Context$Builder> $type;

  @jni$_.internal
  Context$Builder.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/graalvm/polyglot/Context$Builder',
  );

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Context$Builder$NullableType();
  static const type = $Context$Builder$Type();
  static final _id_engine = _class.instanceMethodId(
    r'engine',
    r'(Lorg/graalvm/polyglot/Engine;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _engine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder engine(org.graalvm.polyglot.Engine engine)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? engine(jni$_.JObject? engine) {
    final _$engine = engine?.reference ?? jni$_.jNullReference;
    return _engine(
      reference.pointer,
      _id_engine as jni$_.JMethodIDPtr,
      _$engine.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_out = _class.instanceMethodId(
    r'out',
    r'(Ljava/io/OutputStream;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _out =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder out(java.io.OutputStream out)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? out(jni$_.JObject? out) {
    final _$out = out?.reference ?? jni$_.jNullReference;
    return _out(
      reference.pointer,
      _id_out as jni$_.JMethodIDPtr,
      _$out.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_err = _class.instanceMethodId(
    r'err',
    r'(Ljava/io/OutputStream;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _err =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder err(java.io.OutputStream err)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? err(jni$_.JObject? err) {
    final _$err = err?.reference ?? jni$_.jNullReference;
    return _err(
      reference.pointer,
      _id_err as jni$_.JMethodIDPtr,
      _$err.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_in$ = _class.instanceMethodId(
    r'in',
    r'(Ljava/io/InputStream;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _in$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder in(java.io.InputStream in)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? in$(jni$_.JObject? in$) {
    final _$in$ = in$?.reference ?? jni$_.jNullReference;
    return _in$(
      reference.pointer,
      _id_in$ as jni$_.JMethodIDPtr,
      _$in$.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowHostAccess = _class.instanceMethodId(
    r'allowHostAccess',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowHostAccess =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowHostAccess(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowHostAccess(bool enabled) {
    return _allowHostAccess(
      reference.pointer,
      _id_allowHostAccess as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowHostAccess$1 = _class.instanceMethodId(
    r'allowHostAccess',
    r'(Lorg/graalvm/polyglot/HostAccess;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowHostAccess$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowHostAccess(org.graalvm.polyglot.HostAccess config)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowHostAccess$1(jni$_.JObject? config) {
    final _$config = config?.reference ?? jni$_.jNullReference;
    return _allowHostAccess$1(
      reference.pointer,
      _id_allowHostAccess$1 as jni$_.JMethodIDPtr,
      _$config.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowNativeAccess = _class.instanceMethodId(
    r'allowNativeAccess',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowNativeAccess =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowNativeAccess(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowNativeAccess(bool enabled) {
    return _allowNativeAccess(
      reference.pointer,
      _id_allowNativeAccess as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowCreateThread = _class.instanceMethodId(
    r'allowCreateThread',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowCreateThread =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowCreateThread(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowCreateThread(bool enabled) {
    return _allowCreateThread(
      reference.pointer,
      _id_allowCreateThread as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowAllAccess = _class.instanceMethodId(
    r'allowAllAccess',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowAllAccess =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowAllAccess(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowAllAccess(bool enabled) {
    return _allowAllAccess(
      reference.pointer,
      _id_allowAllAccess as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowHostClassLoading = _class.instanceMethodId(
    r'allowHostClassLoading',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowHostClassLoading =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowHostClassLoading(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowHostClassLoading(bool enabled) {
    return _allowHostClassLoading(
      reference.pointer,
      _id_allowHostClassLoading as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowHostClassLookup = _class.instanceMethodId(
    r'allowHostClassLookup',
    r'(Ljava/util/function/Predicate;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowHostClassLookup =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowHostClassLookup(java.util.function.Predicate<java.lang.String> classFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowHostClassLookup(jni$_.JObject? classFilter) {
    final _$classFilter = classFilter?.reference ?? jni$_.jNullReference;
    return _allowHostClassLookup(
      reference.pointer,
      _id_allowHostClassLookup as jni$_.JMethodIDPtr,
      _$classFilter.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowExperimentalOptions = _class.instanceMethodId(
    r'allowExperimentalOptions',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowExperimentalOptions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowExperimentalOptions(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowExperimentalOptions(bool enabled) {
    return _allowExperimentalOptions(
      reference.pointer,
      _id_allowExperimentalOptions as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowPolyglotAccess = _class.instanceMethodId(
    r'allowPolyglotAccess',
    r'(Lorg/graalvm/polyglot/PolyglotAccess;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowPolyglotAccess =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowPolyglotAccess(org.graalvm.polyglot.PolyglotAccess accessPolicy)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowPolyglotAccess(jni$_.JObject? accessPolicy) {
    final _$accessPolicy = accessPolicy?.reference ?? jni$_.jNullReference;
    return _allowPolyglotAccess(
      reference.pointer,
      _id_allowPolyglotAccess as jni$_.JMethodIDPtr,
      _$accessPolicy.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowValueSharing = _class.instanceMethodId(
    r'allowValueSharing',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowValueSharing =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowValueSharing(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowValueSharing(bool enabled) {
    return _allowValueSharing(
      reference.pointer,
      _id_allowValueSharing as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowInnerContextOptions = _class.instanceMethodId(
    r'allowInnerContextOptions',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowInnerContextOptions =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowInnerContextOptions(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowInnerContextOptions(bool enabled) {
    return _allowInnerContextOptions(
      reference.pointer,
      _id_allowInnerContextOptions as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_hostClassFilter = _class.instanceMethodId(
    r'hostClassFilter',
    r'(Ljava/util/function/Predicate;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _hostClassFilter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder hostClassFilter(java.util.function.Predicate<java.lang.String> classFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? hostClassFilter(jni$_.JObject? classFilter) {
    final _$classFilter = classFilter?.reference ?? jni$_.jNullReference;
    return _hostClassFilter(
      reference.pointer,
      _id_hostClassFilter as jni$_.JMethodIDPtr,
      _$classFilter.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_option = _class.instanceMethodId(
    r'option',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _option =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder option(java.lang.String key, java.lang.String value)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? option(jni$_.JString? key, jni$_.JString? value) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$value = value?.reference ?? jni$_.jNullReference;
    return _option(
      reference.pointer,
      _id_option as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$value.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_options = _class.instanceMethodId(
    r'options',
    r'(Ljava/util/Map;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _options =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder options(java.util.Map<java.lang.String, java.lang.String> options)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? options(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? options,
  ) {
    final _$options = options?.reference ?? jni$_.jNullReference;
    return _options(
      reference.pointer,
      _id_options as jni$_.JMethodIDPtr,
      _$options.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_arguments = _class.instanceMethodId(
    r'arguments',
    r'(Ljava/lang/String;[Ljava/lang/String;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _arguments =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder arguments(java.lang.String language, java.lang.String[] args)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? arguments(
    jni$_.JString? language,
    jni$_.JArray<jni$_.JString?>? args,
  ) {
    final _$language = language?.reference ?? jni$_.jNullReference;
    final _$args = args?.reference ?? jni$_.jNullReference;
    return _arguments(
      reference.pointer,
      _id_arguments as jni$_.JMethodIDPtr,
      _$language.pointer,
      _$args.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowIO = _class.instanceMethodId(
    r'allowIO',
    r'(Lorg/graalvm/polyglot/io/IOAccess;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowIO =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowIO(org.graalvm.polyglot.io.IOAccess ioAccess)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowIO(jni$_.JObject? ioAccess) {
    final _$ioAccess = ioAccess?.reference ?? jni$_.jNullReference;
    return _allowIO(
      reference.pointer,
      _id_allowIO as jni$_.JMethodIDPtr,
      _$ioAccess.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowIO$1 = _class.instanceMethodId(
    r'allowIO',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowIO$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowIO(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowIO$1(bool enabled) {
    return _allowIO$1(
      reference.pointer,
      _id_allowIO$1 as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_fileSystem = _class.instanceMethodId(
    r'fileSystem',
    r'(Lorg/graalvm/polyglot/io/FileSystem;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _fileSystem =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder fileSystem(org.graalvm.polyglot.io.FileSystem fileSystem)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? fileSystem(jni$_.JObject? fileSystem) {
    final _$fileSystem = fileSystem?.reference ?? jni$_.jNullReference;
    return _fileSystem(
      reference.pointer,
      _id_fileSystem as jni$_.JMethodIDPtr,
      _$fileSystem.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_serverTransport = _class.instanceMethodId(
    r'serverTransport',
    r'(Lorg/graalvm/polyglot/io/MessageTransport;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _serverTransport =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder serverTransport(org.graalvm.polyglot.io.MessageTransport serverTransport)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? serverTransport(jni$_.JObject? serverTransport) {
    final _$serverTransport =
        serverTransport?.reference ?? jni$_.jNullReference;
    return _serverTransport(
      reference.pointer,
      _id_serverTransport as jni$_.JMethodIDPtr,
      _$serverTransport.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_logHandler = _class.instanceMethodId(
    r'logHandler',
    r'(Ljava/util/logging/Handler;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _logHandler =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder logHandler(java.util.logging.Handler logHandler)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? logHandler(jni$_.JObject? logHandler) {
    final _$logHandler = logHandler?.reference ?? jni$_.jNullReference;
    return _logHandler(
      reference.pointer,
      _id_logHandler as jni$_.JMethodIDPtr,
      _$logHandler.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_timeZone = _class.instanceMethodId(
    r'timeZone',
    r'(Ljava/time/ZoneId;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _timeZone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder timeZone(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? timeZone(jni$_.JObject? zone) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _timeZone(
      reference.pointer,
      _id_timeZone as jni$_.JMethodIDPtr,
      _$zone.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_logHandler$1 = _class.instanceMethodId(
    r'logHandler',
    r'(Ljava/io/OutputStream;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _logHandler$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder logHandler(java.io.OutputStream logOut)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? logHandler$1(jni$_.JObject? logOut) {
    final _$logOut = logOut?.reference ?? jni$_.jNullReference;
    return _logHandler$1(
      reference.pointer,
      _id_logHandler$1 as jni$_.JMethodIDPtr,
      _$logOut.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowCreateProcess = _class.instanceMethodId(
    r'allowCreateProcess',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowCreateProcess =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowCreateProcess(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowCreateProcess(bool enabled) {
    return _allowCreateProcess(
      reference.pointer,
      _id_allowCreateProcess as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_processHandler = _class.instanceMethodId(
    r'processHandler',
    r'(Lorg/graalvm/polyglot/io/ProcessHandler;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _processHandler =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder processHandler(org.graalvm.polyglot.io.ProcessHandler handler)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? processHandler(jni$_.JObject? handler) {
    final _$handler = handler?.reference ?? jni$_.jNullReference;
    return _processHandler(
      reference.pointer,
      _id_processHandler as jni$_.JMethodIDPtr,
      _$handler.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_resourceLimits = _class.instanceMethodId(
    r'resourceLimits',
    r'(Lorg/graalvm/polyglot/ResourceLimits;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _resourceLimits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder resourceLimits(org.graalvm.polyglot.ResourceLimits limits)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? resourceLimits(jni$_.JObject? limits) {
    final _$limits = limits?.reference ?? jni$_.jNullReference;
    return _resourceLimits(
      reference.pointer,
      _id_resourceLimits as jni$_.JMethodIDPtr,
      _$limits.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_sandbox = _class.instanceMethodId(
    r'sandbox',
    r'(Lorg/graalvm/polyglot/SandboxPolicy;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _sandbox =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder sandbox(org.graalvm.polyglot.SandboxPolicy policy)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? sandbox(jni$_.JObject? policy) {
    final _$policy = policy?.reference ?? jni$_.jNullReference;
    return _sandbox(
      reference.pointer,
      _id_sandbox as jni$_.JMethodIDPtr,
      _$policy.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_allowEnvironmentAccess = _class.instanceMethodId(
    r'allowEnvironmentAccess',
    r'(Lorg/graalvm/polyglot/EnvironmentAccess;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _allowEnvironmentAccess =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder allowEnvironmentAccess(org.graalvm.polyglot.EnvironmentAccess accessPolicy)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? allowEnvironmentAccess(jni$_.JObject? accessPolicy) {
    final _$accessPolicy = accessPolicy?.reference ?? jni$_.jNullReference;
    return _allowEnvironmentAccess(
      reference.pointer,
      _id_allowEnvironmentAccess as jni$_.JMethodIDPtr,
      _$accessPolicy.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_environment = _class.instanceMethodId(
    r'environment',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _environment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder environment(java.lang.String name, java.lang.String value)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? environment(jni$_.JString? name, jni$_.JString? value) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    final _$value = value?.reference ?? jni$_.jNullReference;
    return _environment(
      reference.pointer,
      _id_environment as jni$_.JMethodIDPtr,
      _$name.pointer,
      _$value.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_environment$1 = _class.instanceMethodId(
    r'environment',
    r'(Ljava/util/Map;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _environment$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder environment(java.util.Map<java.lang.String, java.lang.String> env)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? environment$1(
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? env,
  ) {
    final _$env = env?.reference ?? jni$_.jNullReference;
    return _environment$1(
      reference.pointer,
      _id_environment$1 as jni$_.JMethodIDPtr,
      _$env.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_currentWorkingDirectory = _class.instanceMethodId(
    r'currentWorkingDirectory',
    r'(Ljava/nio/file/Path;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _currentWorkingDirectory =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder currentWorkingDirectory(java.nio.file.Path workingDirectory)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? currentWorkingDirectory(jni$_.JObject? workingDirectory) {
    final _$workingDirectory =
        workingDirectory?.reference ?? jni$_.jNullReference;
    return _currentWorkingDirectory(
      reference.pointer,
      _id_currentWorkingDirectory as jni$_.JMethodIDPtr,
      _$workingDirectory.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_hostClassLoader = _class.instanceMethodId(
    r'hostClassLoader',
    r'(Ljava/lang/ClassLoader;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _hostClassLoader =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder hostClassLoader(java.lang.ClassLoader classLoader)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? hostClassLoader(jni$_.JObject? classLoader) {
    final _$classLoader = classLoader?.reference ?? jni$_.jNullReference;
    return _hostClassLoader(
      reference.pointer,
      _id_hostClassLoader as jni$_.JMethodIDPtr,
      _$classLoader.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_useSystemExit = _class.instanceMethodId(
    r'useSystemExit',
    r'(Z)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _useSystemExit =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context$Builder useSystemExit(boolean enabled)`
  /// The returned object must be released after use, by calling the [release] method.
  Context$Builder? useSystemExit(bool enabled) {
    return _useSystemExit(
      reference.pointer,
      _id_useSystemExit as jni$_.JMethodIDPtr,
      enabled ? 1 : 0,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }

  static final _id_build = _class.instanceMethodId(
    r'build',
    r'()Lorg/graalvm/polyglot/Context;',
  );

  static final _build =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Context build()`
  /// The returned object must be released after use, by calling the [release] method.
  Context? build() {
    return _build(
      reference.pointer,
      _id_build as jni$_.JMethodIDPtr,
    ).object<Context?>(const $Context$NullableType());
  }
}

final class $Context$Builder$NullableType
    extends jni$_.JObjType<Context$Builder?> {
  @jni$_.internal
  const $Context$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/graalvm/polyglot/Context$Builder;';

  @jni$_.internal
  @core$_.override
  Context$Builder? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Context$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context$Builder?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$Builder$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$Builder$NullableType) &&
        other is $Context$Builder$NullableType;
  }
}

final class $Context$Builder$Type extends jni$_.JObjType<Context$Builder> {
  @jni$_.internal
  const $Context$Builder$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/graalvm/polyglot/Context$Builder;';

  @jni$_.internal
  @core$_.override
  Context$Builder fromReference(jni$_.JReference reference) =>
      Context$Builder.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context$Builder?> get nullableType =>
      const $Context$Builder$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$Builder$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$Builder$Type) &&
        other is $Context$Builder$Type;
  }
}

/// from: `org.graalvm.polyglot.Context`
class Context extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Context> $type;

  @jni$_.internal
  Context.fromReference(jni$_.JReference reference)
    : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/graalvm/polyglot/Context');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Context$NullableType();
  static const type = $Context$Type();
  static final _id_getEngine = _class.instanceMethodId(
    r'getEngine',
    r'()Lorg/graalvm/polyglot/Engine;',
  );

  static final _getEngine =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Engine getEngine()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? getEngine() {
    return _getEngine(
      reference.pointer,
      _id_getEngine as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_eval = _class.instanceMethodId(
    r'eval',
    r'(Lorg/graalvm/polyglot/Source;)Lorg/graalvm/polyglot/Value;',
  );

  static final _eval =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value eval(org.graalvm.polyglot.Source source)`
  /// The returned object must be released after use, by calling the [release] method.
  value$_.Value? eval(jni$_.JObject? source) {
    final _$source = source?.reference ?? jni$_.jNullReference;
    return _eval(
      reference.pointer,
      _id_eval as jni$_.JMethodIDPtr,
      _$source.pointer,
    ).object<value$_.Value?>(const value$_.$Value$NullableType());
  }

  static final _id_eval$1 = _class.instanceMethodId(
    r'eval',
    r'(Ljava/lang/String;Ljava/lang/CharSequence;)Lorg/graalvm/polyglot/Value;',
  );

  static final _eval$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value eval(java.lang.String languageId, java.lang.CharSequence source)`
  /// The returned object must be released after use, by calling the [release] method.
  value$_.Value? eval$1(jni$_.JString? languageId, jni$_.JObject? source) {
    final _$languageId = languageId?.reference ?? jni$_.jNullReference;
    final _$source = source?.reference ?? jni$_.jNullReference;
    return _eval$1(
      reference.pointer,
      _id_eval$1 as jni$_.JMethodIDPtr,
      _$languageId.pointer,
      _$source.pointer,
    ).object<value$_.Value?>(const value$_.$Value$NullableType());
  }

  static final _id_parse = _class.instanceMethodId(
    r'parse',
    r'(Lorg/graalvm/polyglot/Source;)Lorg/graalvm/polyglot/Value;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value parse(org.graalvm.polyglot.Source source)`
  /// The returned object must be released after use, by calling the [release] method.
  value$_.Value? parse(jni$_.JObject? source) {
    final _$source = source?.reference ?? jni$_.jNullReference;
    return _parse(
      reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$source.pointer,
    ).object<value$_.Value?>(const value$_.$Value$NullableType());
  }

  static final _id_parse$1 = _class.instanceMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/lang/CharSequence;)Lorg/graalvm/polyglot/Value;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value parse(java.lang.String languageId, java.lang.CharSequence source)`
  /// The returned object must be released after use, by calling the [release] method.
  value$_.Value? parse$1(jni$_.JString? languageId, jni$_.JObject? source) {
    final _$languageId = languageId?.reference ?? jni$_.jNullReference;
    final _$source = source?.reference ?? jni$_.jNullReference;
    return _parse$1(
      reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$languageId.pointer,
      _$source.pointer,
    ).object<value$_.Value?>(const value$_.$Value$NullableType());
  }

  static final _id_getPolyglotBindings = _class.instanceMethodId(
    r'getPolyglotBindings',
    r'()Lorg/graalvm/polyglot/Value;',
  );

  static final _getPolyglotBindings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getPolyglotBindings()`
  /// The returned object must be released after use, by calling the [release] method.
  value$_.Value? getPolyglotBindings() {
    return _getPolyglotBindings(
      reference.pointer,
      _id_getPolyglotBindings as jni$_.JMethodIDPtr,
    ).object<value$_.Value?>(const value$_.$Value$NullableType());
  }

  static final _id_getBindings = _class.instanceMethodId(
    r'getBindings',
    r'(Ljava/lang/String;)Lorg/graalvm/polyglot/Value;',
  );

  static final _getBindings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value getBindings(java.lang.String languageId)`
  /// The returned object must be released after use, by calling the [release] method.
  value$_.Value? getBindings(jni$_.JString? languageId) {
    final _$languageId = languageId?.reference ?? jni$_.jNullReference;
    return _getBindings(
      reference.pointer,
      _id_getBindings as jni$_.JMethodIDPtr,
      _$languageId.pointer,
    ).object<value$_.Value?>(const value$_.$Value$NullableType());
  }

  static final _id_initialize = _class.instanceMethodId(
    r'initialize',
    r'(Ljava/lang/String;)Z',
  );

  static final _initialize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean initialize(java.lang.String languageId)`
  bool initialize(jni$_.JString? languageId) {
    final _$languageId = languageId?.reference ?? jni$_.jNullReference;
    return _initialize(
      reference.pointer,
      _id_initialize as jni$_.JMethodIDPtr,
      _$languageId.pointer,
    ).boolean;
  }

  static final _id_resetLimits = _class.instanceMethodId(
    r'resetLimits',
    r'()V',
  );

  static final _resetLimits =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void resetLimits()`
  void resetLimits() {
    _resetLimits(
      reference.pointer,
      _id_resetLimits as jni$_.JMethodIDPtr,
    ).check();
  }

  static final _id_asValue = _class.instanceMethodId(
    r'asValue',
    r'(Ljava/lang/Object;)Lorg/graalvm/polyglot/Value;',
  );

  static final _asValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.graalvm.polyglot.Value asValue(java.lang.Object hostValue)`
  /// The returned object must be released after use, by calling the [release] method.
  value$_.Value? asValue(jni$_.JObject? hostValue) {
    final _$hostValue = hostValue?.reference ?? jni$_.jNullReference;
    return _asValue(
      reference.pointer,
      _id_asValue as jni$_.JMethodIDPtr,
      _$hostValue.pointer,
    ).object<value$_.Value?>(const value$_.$Value$NullableType());
  }

  static final _id_enter = _class.instanceMethodId(r'enter', r'()V');

  static final _enter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void enter()`
  void enter() {
    _enter(reference.pointer, _id_enter as jni$_.JMethodIDPtr).check();
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object obj)`
  bool equals(jni$_.JObject? obj) {
    final _$obj = obj?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$obj.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(r'hashCode', r'()I');

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_leave = _class.instanceMethodId(r'leave', r'()V');

  static final _leave =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void leave()`
  void leave() {
    _leave(reference.pointer, _id_leave as jni$_.JMethodIDPtr).check();
  }

  static final _id_close = _class.instanceMethodId(r'close', r'(Z)V');

  static final _close =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void close(boolean cancelIfExecuting)`
  void close(bool cancelIfExecuting) {
    _close(
      reference.pointer,
      _id_close as jni$_.JMethodIDPtr,
      cancelIfExecuting ? 1 : 0,
    ).check();
  }

  static final _id_close$1 = _class.instanceMethodId(r'close', r'()V');

  static final _close$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void close()`
  void close$1() {
    _close$1(reference.pointer, _id_close$1 as jni$_.JMethodIDPtr).check();
  }

  static final _id_interrupt = _class.instanceMethodId(
    r'interrupt',
    r'(Ljava/time/Duration;)V',
  );

  static final _interrupt =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void interrupt(java.time.Duration timeout)`
  void interrupt(jni$_.JObject? timeout) {
    final _$timeout = timeout?.reference ?? jni$_.jNullReference;
    _interrupt(
      reference.pointer,
      _id_interrupt as jni$_.JMethodIDPtr,
      _$timeout.pointer,
    ).check();
  }

  static final _id_safepoint = _class.instanceMethodId(r'safepoint', r'()V');

  static final _safepoint =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void safepoint()`
  void safepoint() {
    _safepoint(reference.pointer, _id_safepoint as jni$_.JMethodIDPtr).check();
  }

  static final _id_getCurrent = _class.staticMethodId(
    r'getCurrent',
    r'()Lorg/graalvm/polyglot/Context;',
  );

  static final _getCurrent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public org.graalvm.polyglot.Context getCurrent()`
  /// The returned object must be released after use, by calling the [release] method.
  static Context? getCurrent() {
    return _getCurrent(
      _class.reference.pointer,
      _id_getCurrent as jni$_.JMethodIDPtr,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_create = _class.staticMethodId(
    r'create',
    r'([Ljava/lang/String;)Lorg/graalvm/polyglot/Context;',
  );

  static final _create =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.graalvm.polyglot.Context create(java.lang.String[] permittedLanguages)`
  /// The returned object must be released after use, by calling the [release] method.
  static Context? create(jni$_.JArray<jni$_.JString?>? permittedLanguages) {
    final _$permittedLanguages =
        permittedLanguages?.reference ?? jni$_.jNullReference;
    return _create(
      _class.reference.pointer,
      _id_create as jni$_.JMethodIDPtr,
      _$permittedLanguages.pointer,
    ).object<Context?>(const $Context$NullableType());
  }

  static final _id_newBuilder = _class.staticMethodId(
    r'newBuilder',
    r'([Ljava/lang/String;)Lorg/graalvm/polyglot/Context$Builder;',
  );

  static final _newBuilder =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.graalvm.polyglot.Context$Builder newBuilder(java.lang.String[] permittedLanguages)`
  /// The returned object must be released after use, by calling the [release] method.
  static Context$Builder? newBuilder(
    jni$_.JArray<jni$_.JString?>? permittedLanguages,
  ) {
    final _$permittedLanguages =
        permittedLanguages?.reference ?? jni$_.jNullReference;
    return _newBuilder(
      _class.reference.pointer,
      _id_newBuilder as jni$_.JMethodIDPtr,
      _$permittedLanguages.pointer,
    ).object<Context$Builder?>(const $Context$Builder$NullableType());
  }
}

final class $Context$NullableType extends jni$_.JObjType<Context?> {
  @jni$_.internal
  const $Context$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/graalvm/polyglot/Context;';

  @jni$_.internal
  @core$_.override
  Context? fromReference(jni$_.JReference reference) =>
      reference.isNull ? null : Context.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$NullableType) &&
        other is $Context$NullableType;
  }
}

final class $Context$Type extends jni$_.JObjType<Context> {
  @jni$_.internal
  const $Context$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/graalvm/polyglot/Context;';

  @jni$_.internal
  @core$_.override
  Context fromReference(jni$_.JReference reference) =>
      Context.fromReference(reference);
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Context?> get nullableType => const $Context$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Context$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Context$Type) && other is $Context$Type;
  }
}
